#!/usr/bin/env python3
"""
Doc Guardian Git Hooks Installer

Installs post-commit and pre-push hooks that run healing automatically.
Respects existing hooks and allows selective installation.

Usage:
    python guardian/install.py                  # Install all hooks
    python guardian/install.py --hook post-commit
    python guardian/install.py --uninstall
    python guardian/install.py --list           # Show available hooks
    python guardian/install.py --dry-run        # Preview changes
"""

import sys
import os
from pathlib import Path
import argparse
import subprocess
from typing import Tuple, List, Optional

# Version tracking for hook templates
HOOK_VERSION = "1.1.0"

# Exit codes for CI/CD integration
EXIT_SUCCESS = 0
EXIT_PARTIAL = 1
EXIT_ERROR = 2
EXIT_NOT_GIT = 3
EXIT_NO_GUARDIAN = 4

# Minimum Python version required
MIN_PYTHON_VERSION = (3, 7)


def check_python_version() -> None:
    """Check Python version compatibility."""
    if sys.version_info < MIN_PYTHON_VERSION:
        print(f"Error: Python {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]}+ required")
        print(f"Found: Python {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}")
        sys.exit(EXIT_ERROR)


def find_git_root() -> Path:
    """Find the git repository root from current directory."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True
        )
        return Path(result.stdout.strip())
    except FileNotFoundError:
        print("Error: git command not found")
        print("   Ensure git is installed and in your PATH")
        sys.exit(EXIT_NOT_GIT)
    except subprocess.CalledProcessError:
        print("Error: Not in a git repository")
        sys.exit(EXIT_NOT_GIT)


def find_guardian_dir(git_root: Path) -> Path:
    """Find the guardian directory."""
    # Try common locations
    candidates = [
        git_root / "doc-guardian" / "guardian",
        git_root / "guardian",
        git_root / ".guardian",
    ]

    for candidate in candidates:
        if (candidate / "heal.py").exists():
            return candidate

    print("Error: Could not find guardian directory with heal.py")
    print("   Searched:")
    for candidate in candidates:
        print(f"     - {candidate}")
    sys.exit(EXIT_NO_GUARDIAN)


def validate_path(path_str: str) -> bool:
    """Validate path contains no dangerous shell characters.

    Args:
        path_str: Path string to validate

    Returns:
        True if path is safe, False otherwise
    """
    # Allow only safe characters for shell interpolation
    allowed = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-_.')
    return all(c in allowed for c in path_str)


# Hook templates with version tracking
HOOKS = {
    'post-commit': f'''#!/bin/bash
# Doc Guardian post-commit hook v{HOOK_VERSION}
# Auto-generated by guardian/install.py

GUARDIAN_DIR="$(git rev-parse --show-toplevel)/{{guardian_rel_path}}"
PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Find config file (check common locations)
CONFIG_FILE=""
for config in "$PROJECT_ROOT/config.toml" "$PROJECT_ROOT/doc-guardian.toml" "$PROJECT_ROOT/.doc-guardian/config.toml" "$GUARDIAN_DIR/../config.toml"; do
    if [ -f "$config" ]; then
        CONFIG_FILE="$config"
        break
    fi
done

if [ -z "$CONFIG_FILE" ]; then
    echo "Doc Guardian: No config file found, skipping"
    exit 0
fi

# Run healing on high-confidence issues
python3 "$GUARDIAN_DIR/heal.py" --config "$CONFIG_FILE" --heal --min-confidence 0.90

exit 0  # Don't block commit even if healing fails
''',

    'pre-push': f'''#!/bin/bash
# Doc Guardian pre-push hook v{HOOK_VERSION}
# Auto-generated by guardian/install.py

GUARDIAN_DIR="$(git rev-parse --show-toplevel)/{{guardian_rel_path}}"
PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Find config file (check common locations)
CONFIG_FILE=""
for config in "$PROJECT_ROOT/config.toml" "$PROJECT_ROOT/doc-guardian.toml" "$PROJECT_ROOT/.doc-guardian/config.toml" "$GUARDIAN_DIR/../config.toml"; do
    if [ -f "$config" ]; then
        CONFIG_FILE="$config"
        break
    fi
done

if [ -z "$CONFIG_FILE" ]; then
    echo "Doc Guardian: No config file found, skipping validation"
    exit 0
fi

echo "Validating documentation before push..."
python3 "$GUARDIAN_DIR/heal.py" --config "$CONFIG_FILE" --check --verbose

if [ $? -ne 0 ]; then
    echo ""
    echo "Documentation issues detected"
    echo "   Run: python guardian/heal.py --config $CONFIG_FILE --heal"
    echo "   Or use: git push --no-verify to skip"
    exit 1
fi

echo "Documentation validation passed"
exit 0
''',
}


def check_existing_hook(hook_path: Path) -> Tuple[bool, bool, str]:
    """Check if hook exists and determine its type.

    Args:
        hook_path: Path to the hook file

    Returns:
        Tuple of (exists, is_ours, hook_type)
        - exists: Whether the hook file exists
        - is_ours: Whether it's a Doc Guardian hook
        - hook_type: 'file', 'symlink', or 'none'
    """
    # Check symlink first (before exists() which follows symlinks)
    if hook_path.is_symlink():
        return True, False, 'symlink'

    if not hook_path.exists():
        return False, False, 'none'

    try:
        content = hook_path.read_text()
        is_ours = "Doc Guardian" in content
        return True, is_ours, 'file'
    except PermissionError:
        # Can't read, assume not ours
        return True, False, 'file'
    except OSError:
        return True, False, 'file'


def hooks_are_current(hook_path: Path, expected_content: str) -> bool:
    """Check if hook matches expected content (idempotency check).

    Args:
        hook_path: Path to existing hook
        expected_content: Expected hook content

    Returns:
        True if hook content matches expected, False otherwise
    """
    if not hook_path.exists() or hook_path.is_symlink():
        return False
    try:
        return hook_path.read_text() == expected_content
    except (PermissionError, OSError):
        return False


def install_hook(
    hook_name: str,
    git_root: Path,
    guardian_dir: Path,
    force: bool = False,
    dry_run: bool = False
) -> bool:
    """Install a single git hook.

    Args:
        hook_name: Name of the hook (e.g., 'post-commit')
        git_root: Path to git repository root
        guardian_dir: Path to guardian directory
        force: Whether to overwrite existing hooks
        dry_run: If True, show what would be done without making changes

    Returns:
        True if hook was installed/would be installed, False otherwise
    """
    hooks_dir = git_root / ".git" / "hooks"
    hook_path = hooks_dir / hook_name

    # Check hooks directory permissions
    if not dry_run:
        if hooks_dir.exists() and not os.access(hooks_dir, os.W_OK):
            print(f"   Error: Cannot write to {hooks_dir}")
            print(f"   Check directory permissions and try again")
            return False

    # Ensure hooks directory exists
    try:
        if not dry_run:
            hooks_dir.mkdir(exist_ok=True)
    except PermissionError:
        print(f"   Error: Cannot create hooks directory: permission denied")
        return False

    # Validate guardian path
    guardian_rel = guardian_dir.relative_to(git_root)
    guardian_str = str(guardian_rel)

    if not validate_path(guardian_str):
        print(f"   Error: Invalid characters in guardian path: {guardian_str}")
        print(f"   Path must contain only alphanumeric characters, /, -, _, .")
        return False

    # Generate expected content
    hook_content = HOOKS[hook_name].format(guardian_rel_path=guardian_str)

    # Check for existing hook
    exists, is_ours, hook_type = check_existing_hook(hook_path)

    if exists:
        if is_ours:
            # Check if content matches (idempotency)
            if hooks_are_current(hook_path, hook_content):
                print(f"   {hook_name} is already installed and current")
                return True
            # Our hook but outdated - update it
            if dry_run:
                print(f"   Would update existing {hook_name} hook")
                return True
            print(f"   Updating {hook_name} (outdated version)...")
        else:
            # Not our hook
            if hook_type == 'symlink':
                try:
                    target = os.readlink(hook_path)
                except OSError:
                    target = "unknown"
                print(f"   Warning: Existing hook is symlink to: {target}")
                if not force:
                    print(f"   Use --force to remove (symlinks are NOT backed up for security)")
                    return False
                if dry_run:
                    print(f"   Would remove symlink (NOT backed up for security)")
                    return True
                # Remove symlink (DO NOT backup - security risk)
                print(f"   Removing symlink (NOT backed up for security)")
                try:
                    hook_path.unlink()
                except PermissionError:
                    print(f"   Error: Permission denied removing symlink")
                    return False
            else:
                # Regular file
                if not force:
                    print(f"   Warning: {hook_name} already exists (not a Doc Guardian hook)")
                    print(f"   Use --force to overwrite, or manually merge")
                    return False
                # Backup existing hook
                backup_path = hook_path.with_suffix('.backup')
                if dry_run:
                    print(f"   Would backup to {backup_path.name} and install new hook")
                    return True
                print(f"   Backing up existing hook to {backup_path.name}")
                try:
                    hook_path.rename(backup_path)
                except PermissionError:
                    print(f"   Error: Permission denied creating backup")
                    return False

    # Install hook
    if dry_run:
        print(f"   Would install {hook_name} to {hook_path.relative_to(git_root)}")
        return True

    try:
        print(f"   Installing {hook_name}...")
        hook_path.write_text(hook_content)
        hook_path.chmod(0o755)
        print(f"   Installed to {hook_path.relative_to(git_root)}")
        return True
    except PermissionError:
        print(f"   Error: Permission denied writing {hook_path}")
        return False
    except OSError as e:
        print(f"   Error: Failed to write hook: {e}")
        return False


def uninstall_hook(hook_name: str, git_root: Path, dry_run: bool = False) -> bool:
    """Uninstall a git hook.

    Args:
        hook_name: Name of the hook to uninstall
        git_root: Path to git repository root
        dry_run: If True, show what would be done without making changes

    Returns:
        True if hook was uninstalled/would be uninstalled, False otherwise
    """
    hooks_dir = git_root / ".git" / "hooks"
    hook_path = hooks_dir / hook_name

    if not hook_path.exists() and not hook_path.is_symlink():
        print(f"   {hook_name} not found")
        return False

    # Check if it's a symlink (shouldn't restore these)
    is_symlink = hook_path.is_symlink()

    # Verify it's our hook (unless it's a symlink we want to remove)
    if not is_symlink:
        try:
            content = hook_path.read_text()
            if "Doc Guardian" not in content:
                print(f"   {hook_name} exists but is not a Doc Guardian hook")
                print(f"   Skipping (will not remove)")
                return False
        except PermissionError:
            print(f"   Error: Permission denied reading {hook_name}")
            return False

    if dry_run:
        print(f"   Would remove {hook_name}")
        backup_path = hook_path.with_suffix('.backup')
        if backup_path.exists() and not backup_path.is_symlink():
            print(f"   Would restore backup: {backup_path.name}")
        return True

    try:
        hook_path.unlink()
        print(f"   Removed {hook_name}")
    except PermissionError:
        print(f"   Error: Permission denied removing {hook_name}")
        return False

    # Restore backup if exists (but NOT if backup is a symlink - security)
    backup_path = hook_path.with_suffix('.backup')
    if backup_path.exists():
        if backup_path.is_symlink():
            print(f"   Backup is a symlink (NOT restoring for security)")
            print(f"   Removing backup symlink...")
            try:
                backup_path.unlink()
            except PermissionError:
                print(f"   Warning: Could not remove backup symlink")
        else:
            print(f"   Restoring backup: {backup_path.name} -> {hook_name}")
            try:
                backup_path.rename(hook_path)
            except PermissionError:
                print(f"   Warning: Could not restore backup")

    return True


def list_hooks(git_root: Path) -> None:
    """List available hooks and their status.

    Args:
        git_root: Path to git repository root
    """
    hooks_dir = git_root / ".git" / "hooks"

    print("\nAvailable hooks:")
    print("-" * 60)

    for hook_name in HOOKS.keys():
        hook_path = hooks_dir / hook_name

        exists, is_ours, hook_type = check_existing_hook(hook_path)

        if not exists:
            status = "Not installed"
        elif hook_type == 'symlink':
            status = "Installed (symlink - not Doc Guardian)"
        elif is_ours:
            status = "Installed"
        else:
            status = "Installed (not Doc Guardian)"

        print(f"  {hook_name:15} {status}")

    print("-" * 60)
    print(f"\nInstall with: python guardian/install.py --hook <name>")
    print(f"Install all:  python guardian/install.py")
    print(f"Preview:      python guardian/install.py --dry-run")


def main() -> None:
    """Main entry point for the installation script."""
    # Check Python version first
    check_python_version()

    parser = argparse.ArgumentParser(
        description="Install Doc Guardian git hooks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Install all hooks:
    python guardian/install.py

  Install specific hook:
    python guardian/install.py --hook post-commit

  Preview changes (dry run):
    python guardian/install.py --dry-run

  List available hooks:
    python guardian/install.py --list

  Uninstall all hooks:
    python guardian/install.py --uninstall

  Force overwrite existing hooks:
    python guardian/install.py --force

Exit codes:
  0 - Success (all hooks installed)
  1 - Partial success (some hooks installed)
  2 - Error (no hooks installed)
  3 - Not in a git repository
  4 - Guardian directory not found
        """
    )
    parser.add_argument('--hook', choices=list(HOOKS.keys()),
                        help="Install specific hook only")
    parser.add_argument('--uninstall', action='store_true',
                        help="Uninstall hooks")
    parser.add_argument('--list', action='store_true',
                        help="List available hooks and status")
    parser.add_argument('--force', action='store_true',
                        help="Overwrite existing hooks (backs up regular files, removes symlinks)")
    parser.add_argument('--dry-run', action='store_true',
                        help="Show what would be done without making changes")
    parser.add_argument('--version', action='store_true',
                        help="Show hook template version")
    args = parser.parse_args()

    # Version mode
    if args.version:
        print(f"Doc Guardian hook template version: {HOOK_VERSION}")
        sys.exit(EXIT_SUCCESS)

    # Find directories
    git_root = find_git_root()
    guardian_dir = find_guardian_dir(git_root)

    # List mode
    if args.list:
        list_hooks(git_root)
        sys.exit(EXIT_SUCCESS)

    # Dry run indicator
    if args.dry_run:
        print("[DRY RUN] No changes will be made\n")

    # Uninstall mode
    if args.uninstall:
        hooks_to_uninstall = [args.hook] if args.hook else list(HOOKS.keys())

        print(f"Uninstalling Doc Guardian hooks from {git_root}...")
        success_count = 0

        for hook_name in hooks_to_uninstall:
            if uninstall_hook(hook_name, git_root, args.dry_run):
                success_count += 1

        print(f"\nUninstalled {success_count}/{len(hooks_to_uninstall)} hooks")

        if success_count == len(hooks_to_uninstall):
            sys.exit(EXIT_SUCCESS)
        elif success_count > 0:
            sys.exit(EXIT_PARTIAL)
        else:
            sys.exit(EXIT_ERROR)

    # Install mode
    hooks_to_install = [args.hook] if args.hook else list(HOOKS.keys())

    print(f"Installing Doc Guardian hooks to {git_root}...")
    print(f"   Guardian directory: {guardian_dir.relative_to(git_root)}")
    print(f"   Hook version: {HOOK_VERSION}")
    print()

    success_count = 0
    installed_hooks: List[str] = []

    for hook_name in hooks_to_install:
        if install_hook(hook_name, git_root, guardian_dir, args.force, args.dry_run):
            success_count += 1
            installed_hooks.append(hook_name)

    print(f"\nInstalled {success_count}/{len(hooks_to_install)} hooks")

    if success_count > 0 and not args.dry_run:
        print(f"\nHooks will run automatically on git operations:")
        for hook_name in hooks_to_install:
            if hook_name == 'post-commit':
                print(f"  - {hook_name:15} -> Heal high-confidence issues after commits")
            elif hook_name == 'pre-push':
                print(f"  - {hook_name:15} -> Validate docs before push (blocks if failed)")

        print(f"\nTo bypass hooks temporarily:")
        print(f"  git commit --no-verify")
        print(f"  git push --no-verify")

    # Exit with appropriate code
    if success_count == len(hooks_to_install):
        sys.exit(EXIT_SUCCESS)
    elif success_count > 0:
        sys.exit(EXIT_PARTIAL)
    else:
        sys.exit(EXIT_ERROR)


if __name__ == '__main__':
    main()
